## 二分答案
* 在题目中寻找出**单调性**，根据单调性去进行二分做题（类似于二分搜索）
* 二分最终的答案是一个范围，不断通过边界收缩，来获得 ans

## 重要题目：
- [第 K 小的数对距离](#题目四第k小的数对距离)
- [同时运行 n 台电脑的最长时间](#题目五同时运行-n-台电脑的最长时间)

#### 题目一：[爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas)
* 这一题很容易得出单调性，单位时间内吃的越多，就一定会吃完。

#### 题目二：[分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)
* 通过界定最大值来进行分组

<details>
<summary><b>· 详细代码</b></summary>

```cpp
class Solution {
public:
    int splitArray(vector<int>& nums, int k) {
        int l = 0, r = 0;
        for (int i = 0; i < nums.size(); i++)
            l = l > nums[i] ? l : nums[i],
            r += nums[i];

        int ans = r;

        while (l <= r)
        {
            int mid = (l + r) >> 1;
            int tmp = 0, z = 1; // z 表示组数
            for (int i = 0; i W< nums.size();)
            {
                if (tmp + nums[i] <= mid) tmp += nums[i++];
                else tmp = nums[i++], z++;  //超过了阈值，就增加新的一组
            }

            if (z <= k) // 利用阈值分的组，与题目规定组数进行比较即可
                r = mid - 1, ans = mid;
            else
                l = mid + 1;
        }
        return ans;
    }
};
```

</details>

#### 题目三：[机器人跳跃问题](https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71)
* 分析：若是初始能量越大，就越不会损耗能量，题目是根据 E 与 H(k + 1) 的大小关系进行能量判定的。
* **关键点**：若是能量等于 Max(h[i]) 的时候，即为 h 数组中的最大值，那么将不会出现能量损耗的情况，可以判定为通过，这个可以**防止越界**。（原因是通过分析，假设初始能量是 4，h[] = {1,1,1,1,1...}，那么会无限叠加，N 的界限是 10^5，所以最终会出现 2^10^5 的情况，即便是 long long 也无法存储）

<details>
<summary><b>· 详细代码</b></summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
const int N = 1e5 + 10;
int h[N], n;

int Max(int a, int b) { return a > b ? a : b; }
int Min(int a, int b) { return a < b ? a : b; }

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n;
	for (int i = 0; i < n; i++) cin >> h[i];

	int l = N, r = 0;
	for (int i = 0; i < n; i++)
	{
		l = Min(l, h[i]);
		r = Max(r, h[i]);
	}

	int ans = r, maxn = r;

	while (l <= r)
	{
		int mid = (l + r) >> 1;
		bool res = 1;
		int x = mid;
		for (int i = 0; i < n; i++)
		{
			x += x - h[i];
			if (x < 0)
			{
				res = 0;
				break;
			}
			else if (x >= maxn)
				break;
		}

		if (res)
			ans = mid, r = mid - 1;
		else
			l = mid + 1;
	}
	cout << ans << endl;
	return 0;
}
```

</details>

#### 题目四：[第K小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)
* 解法： 二分答案 + 滑动窗口
* 分析：由于时数对之间的**绝对差值**，所以我们可以忽略顺序，先进行排序，在有序的基础上来获得计算的**便利性**

<details>
<summary><b>· 详细代码</b></summary>

```cpp
class Solution {
public:
    int smallestDistancePair(vector<int>& nums, int k) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        int l = 0, r = nums[n - 1] - nums[0], ans = -1;
        while (l <= r)
        {
            int x = (l + r) >> 1;
            int cnt = 0;
			// 这里使用滑动窗口进行统计
            for (int ll = 0, rr = 0; ll < n; ll++)
            {
                while (rr < n - 1 && nums[rr + 1] - nums[ll] <= x) rr++;
                cnt += rr - ll;
            }

            if (cnt < k)
                l = x + 1;
            else	// 特别注意：只有 >= k 的边界条件才是合法答案
                r = x - 1, ans = x;
        }
        return ans;
    }
};
```

</details>


#### 题目五：[同时运行 n 台电脑的最长时间](https://leetcode.cn/problems/maximum-running-time-of-n-computers/)
* 解法： 二分答案 + 贪心
* **碎片电池**的定义：`batterys[i] < x` 的时候，**一定**是**碎片电池**
* 重要结论：
	- **碎片电池**满足：`sum(碎片电池) >= x * n`成立的时候，**一定**可以完成 <b>（碎片拼接） </b>
	- `sum(batterys) >= max(batterys) * n`成立的时候，可以说明此时所有电池都是**碎片电池**，这个时候`ans = sum / n`（贪心）（**优化点**，不加入这个判断也可以 AC）

<details>
<summary><b>· 详细代码</b></summary>

```cpp
#define ll long long
class Solution {
public:
    long long maxRunTime(int n, vector<int>& batteries) {
        int m = batteries.size();
        ll sum = 0, ans = 0, maxn = 0;
        for(int i = 0; i < m; i++) {
            sum += batteries[i];
            maxn = maxn > batteries[i] ? maxn : batteries[i];
        }
        // 贪心（优化）（其实不加可以AC，速度慢一点）
        if (sum >= n * maxn) return sum / n;
        int l = 0, r = maxn;
        // 二分答案
        while(l<=r)
        {
            int x = (l+r)>>1, cnt = 0;
            ll tmp = 0;
            for(int i=0;i<m;i++) 
                if(batteries[i]>=x) cnt++;
                else tmp += batteries[i];
            
            if(tmp >= 1LL * (n-cnt) * x)	// * 1LL 是将 int 转为 longlong 防止溢出
                ans = x, l = x+1;
            else 
                r = x-1;
        }
        return ans;
    }
};
```

</details>


#### 题目六：[计算等位时间（谷歌面试题）]()
* **题目**：给定一个数组 `arr` 长度为 `n`，表示 `n` 个服务员，每服务一个人所需要的时间。给定一个正数 `m`，表示有 `m` 个人在你的**前面**等位，**每个**顾客都**遵循有位就上**的原则，请问你需要等多久？<br>（`m` 远远大于 `n`，比如 `n <= 1e3`，`m <= 1e9`）

<details>
<summary><b>· 堆模拟解法</b></summary>

- 分析：我们可以创建一个结构体，里面有 `next` 表示下一次可以服务的时间，`time` 表示服务所需要的时间，根据 `next` 的大小来创建小根堆。
> 这种解法在 `m` 比较大的时候会 TEL

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'

struct Node {
	int next, time;
	Node() {}
	Node(int next, int time) : next(next), time(time) {}
	bool operator < (const Node &t) const { 
		if(next == t.next) return time > t.time; 
		return next > t.next;
	}
}

const int N = 1e3 + 10;
int n, m;
priority_queue<Node> q;	// 创建优先队列（默认大根堆）

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> m;
	for (int i = 0; i < n; i++)
	{
		int next, time;
		cin >> next >> time;
		q.push(Node(next, time));
	}
	while (m--)
	{
		Node t = q.top(); q.pop();
		q.push(Node(t.next + t.time, t.time));
	}
	cout << q.top().next << endl;
	return 0;
}

```

</details>

<details>
<summary><b>· 二分答案法</b></summary>

- 分析：`l`从 0 开始（当`n > m`的时候），`r`从 `min(arr) * m` 开始。算`mid`这个时间内，服务员总共可以服务多少个人。
- **细节**：`cnt += (mid / arr[i]) + 1` 其中 `+1` 是因为服务员必然服务到 `w[i] + 1` 个人，如果你存在于 `sum(w[i] + 1)` 当中，说明你已经被服务了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'

const int N = 1e3 + 10;
int n, m, arr[N];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> m;
	int minn = 1e9;
	for (int i = 0; i < n; i++) 
	{
		cin >> arr[i];
		minn = minn < arr[i] ? minn : arr[i];
	}
	int l = 0, r = minn * m, ans = -1;
	while (l <= r)
	{
		int x = (l + r) >> 1;
		ll cnt = 0;
		for (int i = 0; i < n; i++) cnt += (x / arr[i]) + 1;
		if (cnt >= m)
			ans = x, r = x - 1;
		else 
			l = x + 1;
	}
	cout << ans << endl;
	return 0;
}
```

</details>

- 在线测试：[完成旅途的最短时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/)

<details>
<summary><b>· 题解</b></summary>

```cpp
#define ll long long
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        int n = time.size(), minn = 1e7 + 5;
        for(int i = 0; i < n; i++) minn = minn < time[i] ? minn : time[i];
        ll l = 0, r = (ll)totalTrips * minn, ans = 0;
        while(l <= r)
        {
            ll x = (l + r) >> 1;
            ll cnt = 0;
            for(int i = 0; i < n; i++) 
            {
                cnt += x / time[i];
                if(cnt >= totalTrips) break;    // 此时说明已经满足要求了
            }
            if(cnt >= totalTrips)
                ans = x, r = x - 1;
            else
                l = x + 1;
        }
        return ans;
    }
};
```

</details>

#### 题目七：[刀砍毒杀怪兽问题]()
- 题目：
	- 怪兽的初始血量是一个整数`hp`，给出每一回合刀砍和毒杀的数值`cuts`和`poisons`
	- 第 i 回合用刀砍，怪兽在这个回合会直接损失`cuts[i]`点血量，不再有后续效果
	- 第 i 回合用毒杀，怪兽在这个回合不会损失血量，但是之后每个回合都损失`poisons[i]`点血量，并且可以在后续回合中叠加
	- 两个数组`cuts`、`poisons`的长度都是`n`，代表你可以进行`n`回合
	- 如果在`n`个回合内没有直接杀死怪兽，那么你将无法继续由新的行动
	- 但是怪兽中毒的话，会一直扣血致死
	- 请返回**至少**多少个会合后，怪兽会死掉
	- 数据范围：`1<=n<=1e5`，`1<=hp<=1e9`，`1<=cuts[i],poisons[i]<=1e9`

- 分析：
	- 这一题从正面去思考，是很难得到答案的，因为无法确定总回合数
	- 可以通过**界定总回合数**来进行一个判断，那么此时就可以有**单调性**（回合越多，怪兽掉血越多），二分答案

<details>
<summary><b>· 示例代码</b></summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define endl '\n'
#define ll long long
const int N = 1e5 + 10;
int n, hp, cuts[N], poisons[N];

il bool check(int x)
{
	ll cnt = 0;
    for(int i = 0; i < n ; i++)
    {
        ll harm = 1LL * cuts[i] > 1LL * poisons[i] * (x - i - 1) ? 1LL * cuts[i] : 1LL * poisons[i] * (x - i - 1);
        cnt += harm;
        if(cnt >= hp) return true;    // 能把怪兽打败
    }
    return false;
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> hp;
    for(int i = 0; i < n; i++) cin >> cuts[i];
    for(int i = 0; i < n; i++) cin >> poisons[i];
    int l = 0, r = hp + 1, ans = -1;
    while(l <= r)
    {
        int mid = (l + r) >> 1;
        if(check(mid))
            r = mid - 1, ans = mid;
        else
            l = mid + 1;
    }
    cout << ans << endl;
    return 0;
}
```

</details>


### 后续练习题目：
1. [在D天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)
2. [制作m束花所需的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/)
3. [H 指数Ⅱ](https://leetcode.cn/problems/h-index-ii/)
4. [乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)
5. [有序矩阵中第k小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)
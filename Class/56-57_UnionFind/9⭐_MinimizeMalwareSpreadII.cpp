// 测试链接 : https://leetcode.cn/problems/minimize-malware-spread-ii/
#include <bits/stdc++.h>
using namespace std;

const int N = 310;
int f[N], fcnt[N];
bool virus[N];
int Max(int a, int b) { return a > b ? a : b; }
int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }
void merge(int a, int b) {
    int fa = find(a), fb = find(b);
    if (fa != fb) f[fb] = fa, fcnt[fa] += fcnt[fb];
}
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size(), m = initial.size();
        sort(initial.begin(), initial.end());
        for (int i = 0; i < n; i++) f[i] = i, fcnt[i] = 1;
        int ans = initial[0], ansfcnt = 0;
        bool flag;
        memset(virus, 0, sizeof(virus));
        for (int i = 0; i < m; i++) virus[initial[i]] = 1;
        for (int i = 0; i < n; i++)
        {
            if (virus[i]) continue;
            flag = 0;
            for (int j = 0; j < n; j++)
            {
                if (!graph[i][j]) continue;
                if (virus[j])
                {
                    if (flag) virus[i] = 1, initial.push_back(i); // 标记为必然感染点
                    flag = 1;
                    continue;
                }
                merge(i, j);
            }
        }

        for (int i = 0, ifcnt = 0, fj, u, j, len = initial.size(); i < m; i++, ifcnt = 0)
        {
            u = initial[i];
            memset(virus, 0, sizeof(virus));
            for (j = 0; j < len; j++) virus[initial[j]] = 1;
            for (j = 0; j < n; j++)
            {
                fj = find(j);
                if (virus[fj] || !graph[u][j]) continue;
                ifcnt += fcnt[fj];
                virus[fj] = 1;
            }

            if (ifcnt > ansfcnt) ansfcnt = ifcnt, ans = u;
        }

        return ans;
    }
};

int main()
{
    vector<vector<int>> graph = { {1,1,0,0},{1,1,0,1},{0,0,1,0},{0,1,0,1} };
    vector<int> initial = { 3,0 };
    cout << Solution().minMalwareSpread(graph, initial) << endl;
    return 0;
}

/*
常数优化更好的代码---其实也是和左神同一版本的cpp代码

vector<int>father;vector<bool>is_virus;vector<int> size_;vector<int>is_infect;//-1没被感染,-2没救了,具体数字只有这个感染源

int find(int i){
    if(father[i] != i){
        father[i] = find(father[i]);
    }
    return father[i];
}

void union_(int i,int j){
    int fi = find(i);int fj = find(j);
    if(fi != fj){
        father[fi] = fj;
        size_[fj] += size_[fi];
    }
}

void build(vector<vector<int>>& graph, vector<int>& initial,int n){
    for(int i = 0;i < n;i++){
        father[i] = i;//初始化自己
    }
    for(int num : initial){
        is_virus[num] = true;//把病毒点显化
    }
    for(int i = 0;i < n;i++){
        for(int j = i + 1;j < n;j++){
            if(!is_virus[i] && !is_virus[j] && graph[i][j] == 1){//两个点都不是病毒并且两点之间有联系
                union_(i,j);
            }  
        }
    }
    for(int virus : initial){
        for(int i = 0;i < n;i++){
            if(virus != i && !is_virus[i] && graph[virus][i] == 1){
                int fi = find(i);//fi是父节点
                if(is_infect[fi] == -1){
                    is_infect[fi] = virus;
                }
                else if(is_infect[fi] != virus){
                    is_infect[fi] = -2;
                }
            }
        }
    }//把所有跟病毒有关的集合都挂上相应的标签
}

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();//有几个点
        father.clear();father = vector<int>(n,0);is_virus.clear();is_virus = vector<bool>(n,false);
        size_.clear();size_ = vector<int>(n,1);is_infect.clear();is_infect = vector<int>(n,-1);//只有父节点会改变
        build(graph,initial,n);
        vector<int>recoding(n,0);//病毒对应的点直接找到//左-》指代的节点 右-》感染的个数
        for(int i = 0;i < n;i++){
            if(find(i) == i && is_infect[i] != -1 && is_infect[i] != -2){//他是管事的且有且只有一个感染源
                recoding[is_infect[i]] += size_[i];
            }
        }//一个感染源感染的个数

        
        sort(initial.begin(),initial.end());
        int ans = initial[0];int max_ = recoding[ans];
        for(int virus : initial){
            if(max_ < recoding[virus]){
                max_ = recoding[virus];
                ans = virus;
            }
        }
        return ans;
    }
};
*/
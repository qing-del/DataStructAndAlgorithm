# 单调栈
## 可复盘题目
- [经典题目系列](#经典题目系列)
    - [子数组的最小值之和](#题目三子数组的最小值之和)
- [扩展应用单调栈](#拓展应用单调栈)

### 经典问题：
1. **每个位置**都求：
    - 当前位置的 **左侧**比当前位置的数字**小**，**且距离最近的位置** 在哪
    - 当前位置的 **右侧**比当前位置的数字**小**，**且距离最近位置** 在哪
2. **每个位置**都求：
    - 当前位置的 **左侧**比当前位置的数字**大**，**且距离最近位置** 在哪
    - 当前位置的 **右侧**比当前位置的数字**大**，**且距离最近位置** 在哪

#### 存在重复数字的单调栈
- 那 **第一类** 问题来举例
- arr = [2, 3, 4, 3, 2, 1, 3, 5, 6, 3, 4, 3, 2]
- 采用**大压小**的单调栈（出现`x <= stack.top()`时弹出）
- **从左到右**遍历一轮之后，会得到左侧 `lans[i]` 正确，右侧 `rans[i]` 需要修正的情况
- **修正**：那么我们`for(int i = n - 1; i >= 0; i--)`方式遍历一轮`rans`，出现`arr[rans[i]] == arr[i]`时，那么取`rans[i] = rans[rans[i]]`使用 while 循环，直到`arr[rans[i]] != arr[i]`即可

## 经典题目系列：
#### 题目一：[单调栈模板](https://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb)

<details>
<summary><b>· 题解代码</b></summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
struct Node 
{
    int l, r;
    Node() {}
    Node(int l, int r) : l(l), r(r) {}
};

const int N = 1e6 + 10;
int arr[N], sta[N], n, s;
Node ans[N];

// sta 数组存放的是 下标
void push(int x) { sta[s++] = x; }
void pop() { s--; }
int top() { return sta[s - 1]; }
int size() { return s; }

int main()
{
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n;
    for (int i = 0; i < n; i++) cin >> arr[i];
    for (int i = 0; i < n; i++) 
    {
        while (size() && arr[top()] >= arr[i]) 
        {
            int tmp = top(); pop();
            ans[tmp] = Node(size() ? top() : -1, i);
        }
        push(i);
    }

    // 此时栈里面剩余的元素的右边已经没有比它更小的值了
    while (size()) 
    {
        int tmp = top(); pop();
        ans[tmp] = Node(size() ? top() : -1, -1);
    }

    // 修正右侧ans
    for (int i = n - 1; i >= 0; i--) 
        while (ans[i].r != -1 && arr[ans[i].r] == arr[i]) ans[i].r = ans[ans[i].r].r;

    for (int i = 0; i < n; i++) 
        cout << ans[i].l << " " << ans[i].r << endl;
    return 0;
}
```

</details>


#### 题目二：[每日温度](https://leetcode.cn/problems/daily-temperatures/)

<details>
<summary><b>· 题解代码</b></summary>

```cpp
const int N = 1e5 + 10;
int sta[N], s;
void push(int x) { sta[++s] = x; }
void pop() { s--; }
int top() { return sta[s]; }
int size() { return s; }
void init() { memset(sta, 0, sizeof(sta)); s = 0; }

class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        init();
        int n = temperatures.size();
        vector<int> ans(n, 0);
        for (int i = n - 1; i >= 0; i--)
        {
            while (size() && temperatures[i] >= temperatures[top()])
            {
                int tmp = top(); pop();
                ans[tmp] = size() ? top() - tmp : 0;
            }
            push(i);
        }

        while (size())
        {
            int tmp = top(); pop();
            ans[tmp] = size() ? top() - tmp : 0;
        }

        return ans;
    }
};
```

</details>


#### 题目三：[子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)
- **分析**：对于这个题目，我们可以知道的是，我们可以批量获得数组中，每个位置的元素，左边与右边都比这个位置元素小的且距离最近的位置。
- **例子分析**：假设`arr = {1,2,7,5,6,8,9,4}`<br>那么`下标为 3 的元素 5`，**左边**第一个比它小的元素是`下标为 1 的 2`，**右边**第一个比它小的元素是`下标为 7 的 4`<br>那么在区间`[2, 3], [2, 4], [2, 5], [2, 6], [3, 3], [3, 4], [3, 5], [3, 6]`这些区间都是可以看作 `min(b) = 5`<br>可以获得其中一个 `sum = 5 * 8 = 40`。
- **获取区间数量**：可以看作`开头`与`结尾`的排列组合，用上面分析的例子来说：（区间必须跨过中间值）
    - `left`即为左边首个小<br>`cur`表示当前位置下标<br>`right`表示右边首个小
    - `开头` = `cur`(3) - `left`(1)<br>`结尾` = `right`(7) - `cur`(3)<br>`num` = `开头` * `结尾`
    - 如果 `left` = -1 时，那么 从 0 - `cur` 都可以作为`开头`<br>如果 `right` = -1 时，那么 从 `cur` - `n` 都可以作为`结尾`
- **易错点**：
    - 这一题中，是不可以修正右边的首个位置小的位置，例如：<br>`arr = {71, 55, 82, 55}`<br>我们不修正的情况下是会得到 `t = {{-1, 1}, {-1, 3}, {1, 3}, {-1, -1}}`，修正之后是 `t = {{-1, 1}, {-1, -1}, {1, 3}, {-1, -1}}`<br>使用修正之后的数组进行计算，会存在遍历到`55`这个元素的时候，都会计算`[0, 3]`这个区间，出现了**重复计算**的情况

<details>
<summary><b>· 题解代码</b></summary>

```cpp
const int P = 1e9 + 7, N = 3e4 + 10;
int sta[N], s, t[N][2];
void pop() { s--; }
int size() { return s; }
void push(int x) { sta[++s] = x; }
int top() { return sta[s]; }
void init() {
    memset(t, 0, sizeof(t));
    memset(sta, 0, sizeof(sta));
    s = 0;
}

class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        init();
        int n = arr.size(), ans = 0;
        for (int i = 0; i < n; i++)
        {
            while (size() && arr[top()] >= arr[i])
            {
                int tmp = top();
                pop();
                t[tmp][0] = size() ? top() : -1;
                t[tmp][1] = i;
            }
            push(i);
        }

        // 清空栈
        while (size())
        {
            int tmp = top();
            pop();
            t[tmp][0] = size() ? top() : -1;
            t[tmp][1] = -1;
        }

        // 修正右侧答案
        // for (int i = n - 1; i >= 0; i--)
        //     while (t[i][1] != -1 && arr[t[i][1]] == arr[i])
        //         t[i][1] = t[t[i][1]][1];

        // 计算 ans
        for (int i = 0; i < n; i++)
        {
            int head = t[i][0] == -1 ? i + 1 : i - t[i][0],
                tail = t[i][1] == -1 ? n - i : t[i][1] - i;
            ans = ((1LL * arr[i] * head * tail % P) + ans) % P;
        }

        return ans;
    }
};
```

```cpp
// 进行常数优化版本
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        init();
        int n = arr.size(), ans = 0;
        for (int i = 0; i < n; i++)
        {
            while (size() && arr[top()] >= arr[i])
            {
                int tmp = top();
                pop();
                t[tmp][0] = size() ? top() : -1;
                t[tmp][1] = i;

                int head = t[tmp][0] == -1 ? tmp + 1 : tmp - t[tmp][0],
                    tail = t[tmp][1] == -1 ? n - tmp : t[tmp][1] - tmp;
                ans = ((1LL * arr[tmp] * head * tail % P) + ans) % P;
            }
            push(i);
        }

        // 清空栈
        while (size())
        {
            int tmp = top();
            pop();
            t[tmp][0] = size() ? top() : -1;
            t[tmp][1] = -1;

            int head = t[tmp][0] == -1 ? tmp + 1 : tmp - t[tmp][0],
                tail = n - tmp;
                ans = ((1LL * arr[tmp] * head * tail % P) + ans) % P;
        }

        return ans;
    }
};
```

</details>

#### 题目四：[柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

<details>
<summary><b>· 解法 1</b></summary>

- 其实类似于**子数组最小值之和**，不过通过分析，区别在于这题需要修正，并且将**累加**的操作转化为**比较**大小
- **易错点**：对矩形左边界与右边界之间的处理极易出错，可以用下面的数据进行检测
- Hack 数据：
    - `[1]`
    - `[1, 1]`
    - `[9, 0]`
    - `[5,4,1,2]`

<details>
<summary><b>· 题解代码</b></summary>

```cpp
const int N = 1e5 + 10;
int sta[N], s, t[N][2];
void pop() { s--; }
int size() { return s; }
void push(int x) { sta[++s] = x; }
int top() { return sta[s]; }
void init() {
    memset(t, 0, sizeof(t));
    memset(sta, 0, sizeof(sta));
    s = 0;
}

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        //if (n == 1) return heights[0];  // 特判 ①
        init();
        for (int i = 0; i < n; i++)
        {
            while (size() && heights[top()] >= heights[i])
            {
                int tmp = top(); pop();
                t[tmp][0] = s ? top() : -1;
                t[tmp][1] = i;
            }
            push(i);
        }

        // 清空栈
        while (size())
        {
            int tmp = top(); pop();
            t[tmp][0] = s ? top() : -1;
            t[tmp][1] = -1;
        }

        // 修正
        for (int i = n - 1; i >= 0; i--)
            while (t[i][1] != -1 && heights[t[i][1]] == heights[i])
                t[i][1] = t[t[i][1]][1];

        int ans = 0, tmp;
        for (int i = 0; i < n; i++)
        {
            int r = t[i][1] == -1 ? n - 1 : t[i][1] - 1,
                l = t[i][0];    // 由于下标从 0 开始，所以 r - l 的结果可能为 0，是 -1 的时候直接取为 -1 即可
            tmp = (r - l ? r - l : 1) * heights[i];
            ans = ans > tmp ? ans : tmp;
        }

        return ans;
    }
};
```

</details>

</details>

<details>
<summary><b>· 解法 2（最优解）</b></summary>

- 解析：使用`以 i 为右边界`的方式进行遍历，常数优化更好，写法更简单

```cpp
const int N = 1e5 + 10;
int sta[N], s;
void pop() { s--; }
int size() { return s; }
void push(int x) { sta[++s] = x; }
int top() { return sta[s]; }
void init() {
    memset(sta, 0, sizeof(sta));
    s = 0;
}

class Solution {
    static int Max(int a, int b) { return a > b ? a : b; }
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size(), ans = 0, left, cur;
        init();
        for (int i = 0; i < n; i++) {
            while (size() && heights[top()] >= heights[i]) {
                cur = top(); pop();
                left = s ? top() : -1;
                ans = Max(ans, heights[cur] * (i - left - 1));
            }
            push(i);
        }

        // 清空栈
        while (size()) {
            cur = top();
            pop();
            left = s ? top() : -1;
            ans = Max(ans, heights[cur] * (n - left - 1));
        }

        return ans;
    }
};
```

</details>


### 拓展应用单调栈
#### 题目四：[最大宽度坡](https://leetcode.cn/problems/maximum-width-ramp/)
- 解法：使用单调栈去**维护**`答案的可能性`